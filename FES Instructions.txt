#FES instructions:

xxx: unsigned number operation
xxxs: signed number operation
xxxb: byte operation

add, adds, addb:    addition, saves the result to register
sub, subs, subb:    substraction, saves the result to register
mul, muls, mulb:    multiplication, saves the result to register
div, divs, divb:    divison, saves the result to register
mod, mods, modb:    modulo, saves the result to register
shl, shlb:          shift left, saves the result to register
shr, shrb:          shift right, saves the result to register
and, andb:          and, saves the result to register
or,  orb:           or, saves the result to register
xor, xorb:          exclusive or, saves the result to register
not, notb:          not, saves the result to register

get, getb:          get the value from memory to register
put, putb:          put the value to memory from register
set, setb:          set the value on register

cpy:                copy from one address to another with size
fll:                fill memory with given byte

num, snum:          cast byte to number
byt:                cast value to byte
inv:                invert number

clt, clts, cltb:    compare less than, set register to zero if true
cgt, cgts, cgtb:    compare greater than, set register to zero if true

jmp:                jump to address
jif:                jump to address if register is zero

halt:               stop all instructions

prt:                print text on screen
prn, prns, prnb:    print number on screen
bck:                moves cursor back x amount of characters
scr:                scroll the screen one line up



#Additional symbols:

r    : register
123  : decimal numbers
-123 : negative decimal numbers
b101 : binary numbers
xABC : hexadecimal numbers
.123 : dereferencing
;ABC : defining constant
,ABC : using the constant
=ABC : defining macro (can't have a name of an existing instruction)
[abc]: macro scope
m0   : macro parameter
/ABC : commenting
ln   : current line number
a16  : give x bytes of memory address
'ABC': text definiton, returns the address


#Using instructions and macros:

	;temp a2
	;hello_world 'Hello World!'

	=inc 1 / increases the number on place
	[
		put ,temp
		add .m0 1
		put m0
		get ,temp
	]

	wrt ,hello_world
	wrt 'A great example!'
	
	set 100
	put xFFFFFFFFFFFFFFF0
	inc xFFFFFFFFFFFFFFF0
	/ at this moment the value on the register is still 100
	/ while the value on the address xFFFFFFFFFFFFFFF0 101
	
	;my_function ln
	inc xFFFFFFFFFFFFFFF0
	jmp ,my_function
	/ with this, we can save the address of the "inc" instruction to a constant
	/ then use it with jmp instruction, increasing the value infinitely